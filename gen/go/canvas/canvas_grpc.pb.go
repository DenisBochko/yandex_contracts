// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v4.25.6
// source: canvas/canvas.proto

package canvasv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Canvas_CreateCanvas_FullMethodName        = "/canvas.Canvas/CreateCanvas"
	Canvas_GetCanvasById_FullMethodName       = "/canvas.Canvas/GetCanvasById"
	Canvas_GetImageById_FullMethodName        = "/canvas.Canvas/GetImageById"
	Canvas_GetImageByIds_FullMethodName       = "/canvas.Canvas/GetImageByIds"
	Canvas_GetCanvasesByUserId_FullMethodName = "/canvas.Canvas/GetCanvasesByUserId"
	Canvas_GetCanvases_FullMethodName         = "/canvas.Canvas/GetCanvases"
	Canvas_UploadImage_FullMethodName         = "/canvas.Canvas/UploadImage"
	Canvas_JoinToCanvas_FullMethodName        = "/canvas.Canvas/JoinToCanvas"
	Canvas_AddToWhiteList_FullMethodName      = "/canvas.Canvas/AddToWhiteList"
	Canvas_UpdateCanvas_FullMethodName        = "/canvas.Canvas/UpdateCanvas"
	Canvas_DeleteCanvas_FullMethodName        = "/canvas.Canvas/DeleteCanvas"
)

// CanvasClient is the client API for Canvas service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CanvasClient interface {
	CreateCanvas(ctx context.Context, in *CreateCanvasRequest, opts ...grpc.CallOption) (*CreateCanvasResponse, error)
	GetCanvasById(ctx context.Context, in *GetCanvasByIdRequest, opts ...grpc.CallOption) (*GetCanvasByIdResponse, error)
	GetImageById(ctx context.Context, in *GetImageByIdRequest, opts ...grpc.CallOption) (*GetImageByIdResponse, error)
	GetImageByIds(ctx context.Context, in *GetImageByIdsRequest, opts ...grpc.CallOption) (*GetImageByIdsResponse, error)
	GetCanvasesByUserId(ctx context.Context, in *GetCanvasesByUserIdRequest, opts ...grpc.CallOption) (*GetCanvasesByUserIdResponse, error)
	GetCanvases(ctx context.Context, in *GetCanvasesRequest, opts ...grpc.CallOption) (*GetCanvasesResponse, error)
	UploadImage(ctx context.Context, in *UploadImageRequest, opts ...grpc.CallOption) (*UploadImageResponse, error)
	JoinToCanvas(ctx context.Context, in *JoinToCanvasRequest, opts ...grpc.CallOption) (*JoinToCanvasResponse, error)
	AddToWhiteList(ctx context.Context, in *AddToWhiteListRequest, opts ...grpc.CallOption) (*AddToWhiteListResponse, error)
	UpdateCanvas(ctx context.Context, in *UpdateCanvasRequest, opts ...grpc.CallOption) (*UpdateCanvasResponse, error)
	DeleteCanvas(ctx context.Context, in *DeleteCanvasRequest, opts ...grpc.CallOption) (*DeleteCanvasResponse, error)
}

type canvasClient struct {
	cc grpc.ClientConnInterface
}

func NewCanvasClient(cc grpc.ClientConnInterface) CanvasClient {
	return &canvasClient{cc}
}

func (c *canvasClient) CreateCanvas(ctx context.Context, in *CreateCanvasRequest, opts ...grpc.CallOption) (*CreateCanvasResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateCanvasResponse)
	err := c.cc.Invoke(ctx, Canvas_CreateCanvas_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasClient) GetCanvasById(ctx context.Context, in *GetCanvasByIdRequest, opts ...grpc.CallOption) (*GetCanvasByIdResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCanvasByIdResponse)
	err := c.cc.Invoke(ctx, Canvas_GetCanvasById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasClient) GetImageById(ctx context.Context, in *GetImageByIdRequest, opts ...grpc.CallOption) (*GetImageByIdResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetImageByIdResponse)
	err := c.cc.Invoke(ctx, Canvas_GetImageById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasClient) GetImageByIds(ctx context.Context, in *GetImageByIdsRequest, opts ...grpc.CallOption) (*GetImageByIdsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetImageByIdsResponse)
	err := c.cc.Invoke(ctx, Canvas_GetImageByIds_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasClient) GetCanvasesByUserId(ctx context.Context, in *GetCanvasesByUserIdRequest, opts ...grpc.CallOption) (*GetCanvasesByUserIdResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCanvasesByUserIdResponse)
	err := c.cc.Invoke(ctx, Canvas_GetCanvasesByUserId_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasClient) GetCanvases(ctx context.Context, in *GetCanvasesRequest, opts ...grpc.CallOption) (*GetCanvasesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCanvasesResponse)
	err := c.cc.Invoke(ctx, Canvas_GetCanvases_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasClient) UploadImage(ctx context.Context, in *UploadImageRequest, opts ...grpc.CallOption) (*UploadImageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UploadImageResponse)
	err := c.cc.Invoke(ctx, Canvas_UploadImage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasClient) JoinToCanvas(ctx context.Context, in *JoinToCanvasRequest, opts ...grpc.CallOption) (*JoinToCanvasResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JoinToCanvasResponse)
	err := c.cc.Invoke(ctx, Canvas_JoinToCanvas_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasClient) AddToWhiteList(ctx context.Context, in *AddToWhiteListRequest, opts ...grpc.CallOption) (*AddToWhiteListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddToWhiteListResponse)
	err := c.cc.Invoke(ctx, Canvas_AddToWhiteList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasClient) UpdateCanvas(ctx context.Context, in *UpdateCanvasRequest, opts ...grpc.CallOption) (*UpdateCanvasResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateCanvasResponse)
	err := c.cc.Invoke(ctx, Canvas_UpdateCanvas_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasClient) DeleteCanvas(ctx context.Context, in *DeleteCanvasRequest, opts ...grpc.CallOption) (*DeleteCanvasResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteCanvasResponse)
	err := c.cc.Invoke(ctx, Canvas_DeleteCanvas_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CanvasServer is the server API for Canvas service.
// All implementations must embed UnimplementedCanvasServer
// for forward compatibility.
type CanvasServer interface {
	CreateCanvas(context.Context, *CreateCanvasRequest) (*CreateCanvasResponse, error)
	GetCanvasById(context.Context, *GetCanvasByIdRequest) (*GetCanvasByIdResponse, error)
	GetImageById(context.Context, *GetImageByIdRequest) (*GetImageByIdResponse, error)
	GetImageByIds(context.Context, *GetImageByIdsRequest) (*GetImageByIdsResponse, error)
	GetCanvasesByUserId(context.Context, *GetCanvasesByUserIdRequest) (*GetCanvasesByUserIdResponse, error)
	GetCanvases(context.Context, *GetCanvasesRequest) (*GetCanvasesResponse, error)
	UploadImage(context.Context, *UploadImageRequest) (*UploadImageResponse, error)
	JoinToCanvas(context.Context, *JoinToCanvasRequest) (*JoinToCanvasResponse, error)
	AddToWhiteList(context.Context, *AddToWhiteListRequest) (*AddToWhiteListResponse, error)
	UpdateCanvas(context.Context, *UpdateCanvasRequest) (*UpdateCanvasResponse, error)
	DeleteCanvas(context.Context, *DeleteCanvasRequest) (*DeleteCanvasResponse, error)
	mustEmbedUnimplementedCanvasServer()
}

// UnimplementedCanvasServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCanvasServer struct{}

func (UnimplementedCanvasServer) CreateCanvas(context.Context, *CreateCanvasRequest) (*CreateCanvasResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCanvas not implemented")
}
func (UnimplementedCanvasServer) GetCanvasById(context.Context, *GetCanvasByIdRequest) (*GetCanvasByIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCanvasById not implemented")
}
func (UnimplementedCanvasServer) GetImageById(context.Context, *GetImageByIdRequest) (*GetImageByIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetImageById not implemented")
}
func (UnimplementedCanvasServer) GetImageByIds(context.Context, *GetImageByIdsRequest) (*GetImageByIdsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetImageByIds not implemented")
}
func (UnimplementedCanvasServer) GetCanvasesByUserId(context.Context, *GetCanvasesByUserIdRequest) (*GetCanvasesByUserIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCanvasesByUserId not implemented")
}
func (UnimplementedCanvasServer) GetCanvases(context.Context, *GetCanvasesRequest) (*GetCanvasesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCanvases not implemented")
}
func (UnimplementedCanvasServer) UploadImage(context.Context, *UploadImageRequest) (*UploadImageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadImage not implemented")
}
func (UnimplementedCanvasServer) JoinToCanvas(context.Context, *JoinToCanvasRequest) (*JoinToCanvasResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JoinToCanvas not implemented")
}
func (UnimplementedCanvasServer) AddToWhiteList(context.Context, *AddToWhiteListRequest) (*AddToWhiteListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddToWhiteList not implemented")
}
func (UnimplementedCanvasServer) UpdateCanvas(context.Context, *UpdateCanvasRequest) (*UpdateCanvasResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCanvas not implemented")
}
func (UnimplementedCanvasServer) DeleteCanvas(context.Context, *DeleteCanvasRequest) (*DeleteCanvasResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCanvas not implemented")
}
func (UnimplementedCanvasServer) mustEmbedUnimplementedCanvasServer() {}
func (UnimplementedCanvasServer) testEmbeddedByValue()                {}

// UnsafeCanvasServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CanvasServer will
// result in compilation errors.
type UnsafeCanvasServer interface {
	mustEmbedUnimplementedCanvasServer()
}

func RegisterCanvasServer(s grpc.ServiceRegistrar, srv CanvasServer) {
	// If the following call pancis, it indicates UnimplementedCanvasServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Canvas_ServiceDesc, srv)
}

func _Canvas_CreateCanvas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCanvasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServer).CreateCanvas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Canvas_CreateCanvas_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServer).CreateCanvas(ctx, req.(*CreateCanvasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Canvas_GetCanvasById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCanvasByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServer).GetCanvasById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Canvas_GetCanvasById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServer).GetCanvasById(ctx, req.(*GetCanvasByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Canvas_GetImageById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetImageByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServer).GetImageById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Canvas_GetImageById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServer).GetImageById(ctx, req.(*GetImageByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Canvas_GetImageByIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetImageByIdsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServer).GetImageByIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Canvas_GetImageByIds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServer).GetImageByIds(ctx, req.(*GetImageByIdsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Canvas_GetCanvasesByUserId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCanvasesByUserIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServer).GetCanvasesByUserId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Canvas_GetCanvasesByUserId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServer).GetCanvasesByUserId(ctx, req.(*GetCanvasesByUserIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Canvas_GetCanvases_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCanvasesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServer).GetCanvases(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Canvas_GetCanvases_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServer).GetCanvases(ctx, req.(*GetCanvasesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Canvas_UploadImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServer).UploadImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Canvas_UploadImage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServer).UploadImage(ctx, req.(*UploadImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Canvas_JoinToCanvas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinToCanvasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServer).JoinToCanvas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Canvas_JoinToCanvas_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServer).JoinToCanvas(ctx, req.(*JoinToCanvasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Canvas_AddToWhiteList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddToWhiteListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServer).AddToWhiteList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Canvas_AddToWhiteList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServer).AddToWhiteList(ctx, req.(*AddToWhiteListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Canvas_UpdateCanvas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateCanvasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServer).UpdateCanvas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Canvas_UpdateCanvas_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServer).UpdateCanvas(ctx, req.(*UpdateCanvasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Canvas_DeleteCanvas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCanvasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServer).DeleteCanvas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Canvas_DeleteCanvas_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServer).DeleteCanvas(ctx, req.(*DeleteCanvasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Canvas_ServiceDesc is the grpc.ServiceDesc for Canvas service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Canvas_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "canvas.Canvas",
	HandlerType: (*CanvasServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCanvas",
			Handler:    _Canvas_CreateCanvas_Handler,
		},
		{
			MethodName: "GetCanvasById",
			Handler:    _Canvas_GetCanvasById_Handler,
		},
		{
			MethodName: "GetImageById",
			Handler:    _Canvas_GetImageById_Handler,
		},
		{
			MethodName: "GetImageByIds",
			Handler:    _Canvas_GetImageByIds_Handler,
		},
		{
			MethodName: "GetCanvasesByUserId",
			Handler:    _Canvas_GetCanvasesByUserId_Handler,
		},
		{
			MethodName: "GetCanvases",
			Handler:    _Canvas_GetCanvases_Handler,
		},
		{
			MethodName: "UploadImage",
			Handler:    _Canvas_UploadImage_Handler,
		},
		{
			MethodName: "JoinToCanvas",
			Handler:    _Canvas_JoinToCanvas_Handler,
		},
		{
			MethodName: "AddToWhiteList",
			Handler:    _Canvas_AddToWhiteList_Handler,
		},
		{
			MethodName: "UpdateCanvas",
			Handler:    _Canvas_UpdateCanvas_Handler,
		},
		{
			MethodName: "DeleteCanvas",
			Handler:    _Canvas_DeleteCanvas_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "canvas/canvas.proto",
}
